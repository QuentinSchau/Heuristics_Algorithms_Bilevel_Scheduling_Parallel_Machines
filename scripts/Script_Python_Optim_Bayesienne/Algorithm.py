################################################################################
##### This file contains the code that interacts with the algorithm to optimize
################################################################################
##### Initial version : Thomas CIRON, 2022-2023
##### Revision : Ronan BOCQUILLON, september 2024
##### Revision : Vincent T'KINDT, october 2024
##### Revision : Quentin SCHAU, january 2026
################################################################################
import functools
#Inclusion of mandatory librairies
import json
import os
import subprocess
import math
import pandas as pd

#Local variables with their default value
ADEBUG=False
ALGName=""          #Name of the executable file corresponding to the algorithm to optimize
ALGResFile=""       #Directory where to write the result file generated by the algorithm and that contains: objective_function_value CPU_time
ALGRepetitions=1    #Number of executions to perform on the same instance (set >1 if the algorithm is influenced by random numbers)

################################################################################
### Depending on the algorithm you want to optimize, you need to specify
### for each parameter of the algorithm its meaning. Each parameter can result
### from the learning model you have defined. For instance, to learn the total
### allowed CPU time T, you may define T=a*n+b and thus learn a and b.
### The set of parameters is defined here (e.g., T) and the learned values (e.g.
### a and b) are defined in the module BayesianProcess
################################################################################
### Param 1: XXXXXX
### Param 2: YYYYYY
### ...
################################################################################

################################################################################
### Get_instance_attributes: Get instances attributes such as N,n,m
################################################################################
def Get_instance_attributes(file_path: str):
    """
    Opens the instance file and return N,n and m.
    """
    N,n,m = 0,0,0
    with open(file_path, 'r') as f:
        for i,line in enumerate(f):
            if line.startswith("N:"):
                N = int(line.split("N:")[1].strip())
            if line.startswith("n:"):
                n = int(line.split("n:")[1].strip())
            if line.startswith("M_max:"):
                m += int(line.split("M_max:")[1].strip())
            if line.startswith("M_0:"):
                m += int(line.split("M_0:")[1].strip())
    return N,n,m

################################################################################
### Create_Param: Create the algorithm parameters from a set of values
### NOTE: This refers to the Bayesian learning model defined by the user
################################################################################
def Create_Param(DataFile:str,index_instance:int,alpha1:float,alpha2:float,alpha3:float,alpha4:float,alpha5:float,alpha6:float,alpha7:float,alpha8:float):
    """!
    This function runs the algorithm on the specified input data and for the given set of parameters: each parameter must be taken as a command line option of the algorithm
    NOTE: the list of parameters and the call below must be particularized depending on your algorithm !!!!!!
    @param NbJobs, int, the number of elements(jobs) in the instance
    @param the next parameters are the learned parameter as described in the configuration file conf.json
    @return the parameters
    """
    # get param of instance
    N,n,m = Get_instance_attributes(DataFile)
    #Creating the parameters
    temp_dir = os.path.join(os.path.dirname(__file__),"temp/")
    os.makedirs(temp_dir, exist_ok=True)
    temp_file_output = os.path.join(temp_dir, f"N_{N}_{index_instance}_resultsBeamSearch.csv")
    W = math.floor(math.exp(alpha1*N+alpha2) + alpha3 * m ) + alpha4
    alpha = min(alpha5 * N + alpha6*n + alpha7*m + alpha8,1.0)
    JSON_param={
        "solve": {
            "verbose": 0,
            "output": os.path.join(temp_dir, f"N_{N}_{index_instance}_"),
            "methods": [
                {
                    "name": "BeamSearch",
                    "verbose": 0,
                    "timeLimits": 60,
                    "beamSize": W,
                    "alpha": alpha,
                    "recovering": True,
                    "LocalSearch_parameters": {
                        "name": "LocalSearch",
                        "timeLimits": 0,
                        "version": 1,
                        "verbose": 0,
                        "useBestNeighbor": True,
                        "maxIter": 100
                    },
                    "reco-strategy": "local-search",
                    "nbSolutionForMSLS": 0,
                    "version": 3,
                    "instances": [
                        {
                            "path": os.path.join(os.path.dirname(__file__),DataFile)
                        }
                    ]
                }
            ]
        }
    }
    temp_file = os.path.join(temp_dir,f"temp_N{N}_{index_instance}.json")
    if (ADEBUG):
        print(f"Save JSON file {temp_file} to solve instance")
    with open(temp_file, 'w') as file:
        file.write(json.dumps(JSON_param))
    return temp_file,temp_file_output


################################################################################
### Run: run the algorithm on the input instance file and for a given set of parameters
### NOTE: the list of parameter as to be adjusted depending on your algorithm
################################################################################
def Run(evalFile:str,nb_jobs:int,alpha1:float,alpha2:float,alpha3:float,alpha4:float,alpha5:float,alpha6:float,alpha7:float,alpha8:float,index_instance:int):
    """!
    This function runs the algorithm on the specified input data and for the given set of parameters: each parameter must be taken as a command line option of the algorithm
    NOTE: the list of parameters and the call below must be particularized depending on your algorithm !!!!!!
    @param DataFile, str, the name of the file containing the instance to solve
    @param ResFile, str, the name of the file in which the results have to be put
    @param NbJobs, int, the number of elements(jobs) in the instance
    @param the next parameters are the learned parameter as described in the configuration file conf.json, except the last one that is used to compute the parameters
    """
    DataFile = f"{evalFile}/donnees_{nb_jobs}_{index_instance + 1}.dat"
    ResFile= f"{ALGResFile}/donnees_{nb_jobs}_{index_instance + 1}.dat.seq"
    #Creating the parameters
    if (ADEBUG==True):
        print("Creating the parameters")

    temp_file,temp_file_output=Create_Param(DataFile,index_instance,alpha1,alpha2,alpha3,alpha4,alpha5,alpha6,alpha7,alpha8)

    if (ADEBUG==True):
        print("Running the algorithm")
    subprocess.run([ALGName, temp_file])

    # get result an put it in ResFile
    if (ADEBUG==True):
        print("Creating the result file")

    df = pd.read_csv(temp_file_output,sep="\t")
    row = df.iloc[0]
    obj,time=row.get("Objective"), row.get("Time")
    os.makedirs(os.path.dirname(ResFile), exist_ok=True)
    with open(ResFile, 'w') as file:
        file.write(f"{obj} {time}")
    # delete tempory files
    os.remove(temp_file)
    os.remove(temp_file_output)

################################################################################
### Get_objective_function_value: read the objective function value computed
### by the algorithm. It is assumed that this value is the first value in the file
################################################################################
def Get_objective_function_value(instance_path:str)->float:
    """!
    Get the function objective value of a given instance. The result of an instance is written in a text file, with the processed time and the best found order.
    They are delimited by spaces. The function objective value is the first characters of the file.
    @param path the instance path.
    @return the function objective value.
    """
    with open(instance_path,"r") as f:
        data = f.read().split(" ")
    return float(data[0])

################################################################################
### Get_execution_time: read the CPU time taken by the algorithm.
### It is assumed that this value is the second value in the file
################################################################################
def Get_execution_time(instance_path:str)->float:
    """!
    Get the time spent to compute this result. Compute this for a given instance.
    @param instance_path the instance path we want the execution time from
    @return the execution time
    """
    with open(instance_path, "r") as f:
        data = f.read().split(" ")
    return float(data[1])

################################################################################
### Get_UpperBound: read the instance file. Compute an upper bound of the solution
################################################################################
def Get_UpperBound(base:str,nb_jobs: int,i:int)->float:
    # read instance file, take the n greater weight as an upper of the objective function to normalize
    weights = []
    nbJobToSelect = 0
    with open(f"{base}/donnees_{nb_jobs}_{i + 1}.dat", "r") as f:

        for indexLine,line in enumerate(f.readlines()):
            if indexLine == 2:
                nbJobToSelect = int(line.split(':')[1])
            if indexLine > 7:
                weights.append(int(line.split('\t')[2]))

    weights.sort(reverse=True)
    return functools.reduce(lambda x,y : x+y, weights[:nbJobToSelect])


